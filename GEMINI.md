# Project Context: YouTube Transcript RAG Pipeline & CMM Design System Study

## 1. Executive Summary
This project serves a dual purpose:
1.  **Functional:** A Retrieval-Augmented Generation (RAG) pipeline that ingests individual YouTube videos (Phase 2), extracts transcripts, vectorizes them, and allows users to chat with the video content. Eventually (in Phase 4), the goal is to allow the user to select several videos from a YouTube channel (or several channels) and a time window or multi-video select feature to give more context and depth to the references.
    1. Standout Feature: Time-Referenced Video Deep Links. The core innovation of this RAG pipeline is the Time-Referenced Video Deep Link. Unlike standard chatbots that provide opaque summaries, this application bridges the gap between the generated answer and the source truth.Precision Citations: Every claim generated by the LLM is backed by a specific segment of the transcript. The system identifies the exact start time of the relevant context.
       1. Instant Verification: Citations are rendered as interactive timestamps (e.g., [04:23]). Clicking these links opens the source YouTube video at that exact second, allowing users to immediately verify the AI's interpretation against the original audio and visual context.
       2. Contextual Anchoring: This feature transforms the application from a simple summarizer into a Zero Trust research tool, where the user can always "audit" the AI's reasoning by viewing the primary source material.

2.  **Educational (CMM Alignment):** A "Zero Trust" Federal Design System sandbox. The UI architecture mirrors the specific requirements of the **Case Management Modernization (CMM)** program, focusing on **USWDS compliance**, **Design Tokens (Style Dictionary)**, **Tailwind CSS**, and strict **Section 508 Accessibility**.

## 2. Technical Architecture

### Frontend (The CMM Sandbox)
* **Framework:** React 18 + Vite (Matching CMM's "ReactJS" requirement).
* **Styling Engine:** Tailwind CSS (Utility-first) + CSS Modules (Legacy support).
* **Design System:**
    * **Base:** USWDS (United States Web Design System) via `@trussworks/react-uswds`.
    * **Tokens:** Style Dictionary (v4) managing "Single Source of Truth" for brand colors, typography, and spacing.
    * **Architecture:** "Sandwich Strategy" using CSS Layers (`@layer base, uswds, cmm, utilities`) to manage specificity between USWDS defaults and Tailwind overrides.
* **Language:** TypeScript (Strict Mode).

### Backend (The RAG Engine)
* *Note: While CMM uses NodeJS for frontend serving, this RAG pipeline uses Python to leverage the AI/ML ecosystem.*
* **API:** FastAPI (Python 3.12+).
* **Vector Database:** ChromaDB or Pinecone.
* **LLM Integration:** LangChain / LlamaIndex.
* **Transcription:** YouTube Transcript API.

## 3. CMM Role Alignment & Learning Objectives
This project specifically targets the **UI Styling Specialist** competencies:

* **Design Ops:** Implementing an automated token pipeline (`json` -> `css`/`js`/`ts`) to simulate maintaining a "unified visual identity" across modules.
* **Accessibility (508/WCAG):** Utilizing USWDS components to ensure screen reader compatibility and high-contrast compliance by default.
* **Responsive Layouts:** Using USWDS Grid and Tailwind flex/grid utilities to build "scalable, production-ready" interfaces.
* **System Architecture:** Decoupling "Design Decisions" (Tokens) from "Implementation Details" (CSS/Components).

## 4. Current State (Frontend)
* **Token Pipeline:** Functional. `sd.config.js` generates CSS variables and a flat JSON file for Tailwind.
* **Component Library:**
    * `CmmButton`: A multi-variant wrapper around USWDS Button (Primary/Gold) demonstrating brand-specific overrides implemented via custom CSS rules within the `cmm` layer, leveraging cascade layer precedence.
    * `CmmUrlInput`: A 508-compliant form group for data ingestion.
    * `CmmTranscriptCard`: A high-density data display component for transcript segments, utilizing typography tokens.
    * `TestTranscriptCardPage`: A paginated display of `CmmTranscriptCard` components, showcasing URL-driven navigation and accessible pagination controls.
* **Routing:** Client-side routing implemented with `react-router-dom` for multi-page navigation.
* **Pagination:** Accessible, URL-driven pagination system integrated for list displays.
* **Storybook Documentation:** Comprehensive descriptions added to all existing Storybook stories for better context and understanding.
* **Layer Architecture:** `index.css` successfully implements cascade layers (`base`, `uswds`, `cmm`, `utilities`) to manage specificity, ensuring `cmm` overrides USWDS defaults and unlayered Tailwind utilities maintain their priority without relying on `!important` prefixes.
* **Typography Tokenization:** Abstracted font families (`Inter`, `Merriweather`) and weights into `src/tokens/cmm/typography.json`.
* **Custom Transcript Card:** Created a high-density data display component (typical of Case Management systems) using the new typography tokens.
* **Automated "Zero Trust" Accessibility Pipeline:**
    * Installed `storybook-addon-a11y` to visualize WCAG compliance in real-time.
    * Installed `vitest-axe` and implemented a unit test that asserts `expect(container).toHaveNoViolations()` for the `CmmTranscriptCard`.
* **Semantic Token "Aliasing" (DesignOps):** Refactor `src/tokens` to use a 3-tier structure (Base -> Semantic -> Component). Update Style Dictionary to resolve aliases (e.g., `button.primary.bg` -> `color.action.blue` -> `#005ea2`).

## 5. Roadmap & Next Steps

### Phase 1: Advanced UI & DesignOps (GDIT Skill Gap Closure)
* [ ] **High-Performance Virtualization:** Implement `@tanstack/react-virtual` for the Transcript Viewer to render large datasets without DOM performance degradation. Aim for TTI < 2s.

#### Phase 1.5: Further Study and GDIT Skills Gap Closure
* [ ] **DevSecOps Containerization (DevContainers)II
Why: This is specifically designed for local environments. By setting up .devcontainer, you prove you can enforce a standard environment for any developer who clones your repo, mirroring how federal teams standardize onboarding.
Local Action: Install Docker Desktop and the "Dev Containers" extension in VS Code. Create the config to lock your Node version and extensions.

* [ ] **Federal Accessibility Standards (Trusted Tester V5 + VPAT)**
Why: This is a manual auditing process. It requires no infrastructure, just your browser and a spreadsheet (the VPAT).
Local Action: Install the "ANDI" (Accessible Name & Description Inspector) browser bookmarklet (the modern alternative to WAT) and fill out a mock VPAT for your CmmTranscriptCard.

* [ ] **Design System Governance & Versioning**
Why: This operates entirely within Git. You don't need a remote CI server to manage versioning.
Local Action: Install @changesets/cli. Run npx changeset locally after making a CSS change to see how it generates a changelog entry.

* [ ] **SSR Hydration & Performance**
Why: This is pure code. You can test "Flash of Unstyled Content" (FOUC) by throttling your network speed in Chrome DevTools to "Slow 3G" running on localhost.
Local Action: Implement the <head> script updates in your index.html (Vite) and verify the painting performance in Chrome's "Performance" tab.

### Phase 2: Backend RAG Implementation
- [ ] **Initialize Python Environment:** Set up `poetry` or `venv` with FastAPI dependencies.
- [ ] **Ingestion Endpoint:** Create `POST /ingest` to accept a URL and return a job ID.
- [ ] **Transcript Service:** Implement the logic to fetch and clean YouTube subtitles.
- [ ] **Vector Store Connection:** Set up the embedding model and database connection.

### Phase 3: Integration & State Management
- [ ] **Deep Link State Optimization:** Create a custom `useTranscriptSync` hook to manage focus between the video player and transcript list without causing full-list re-renders (using `React.memo`).
- [ ] **Connect Frontend/Backend:** Link React `IngestionForm` to FastAPI endpoints.
- [ ] **Streaming Chat Interface:** Build the chat UI for RAG results.

### Phase 4: Multi-Video & Channel-Level Intelligence

Objective: Move beyond single-video analysis to enable broad, channel-wide synthesis and comparative research.

Key Capabilities:

Multi-Video Selection: Allow users to select and ingest multiple distinct videos simultaneously to create a composite knowledge base.

Channel Ingestion: Implement a crawler to fetch all (or a subset of) videos from a specific YouTube channel URL.

Temporal Filtering: Add time-window controls (e.g., "Ingest videos published between Jan 2023 and Dec 2023") to refine the context.

Cross-Reference Synthesis: Enable the RAG engine to draw connections and contrast information across multiple videos, providing deeper context and comprehensive topic coverage.

## Custom Instructions
Keep these instrucitons in mind when performing tasks: 
- New components should always be created with their accompanying story in Storybook
- Component updates and new patters should also be addressed in Storybook
- Do not inherintely run any `git` command, `npm start dev`, `npm start storybook`, `npm run build`, or `npm i` actions unless explicitly instructed. Instead ask the user to run these commands and report back the results.
- Keep GEMINI.md and README.md updated as necessary.