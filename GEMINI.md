# Project Context: YouTube Transcript RAG Pipeline & CMM Design System Study

## 1. Executive Summary
This project serves a dual purpose:
1.  **Functional:** A Retrieval-Augmented Generation (RAG) pipeline that ingests YouTube videos and playlists (Phase 2), extracts transcripts, vectorizes them, and allows users to chat with the video content. 
    * **Standout Feature: Time-Referenced Video Deep Links.** The core innovation of this RAG pipeline is the Time-Referenced Video Deep Link. Unlike standard chatbots that provide opaque summaries, this application bridges the gap between the generated answer and the source truth.
        * **Precision Citations:** Every claim generated by the LLM is backed by a specific segment of the transcript. The system identifies the exact start time of the relevant context.
        * **Instant Verification:** Citations are rendered as interactive timestamps (e.g., `[04:23]`). Clicking these links opens the source YouTube video at that exact second, allowing users to immediately verify the AI's interpretation against the original audio and visual context.
        * **Contextual Anchoring:** This feature transforms the application from a simple summarizer into a **Zero Trust** research tool, where the user can always "audit" the AI's reasoning by viewing the primary source material.

2.  **Educational (CMM Alignment):** A "Zero Trust" Federal Design System sandbox. The UI architecture mirrors the specific requirements of the **Case Management Modernization (CMM)** program, focusing on **USWDS compliance**, **Design Tokens (Style Dictionary)**, **Tailwind CSS**, and strict **Section 508 Accessibility**.

## 2. Technical Architecture

### **Frontend (`/frontend`)**
* **Stack:** React 18 + Vite + TypeScript.
* **Design System:** USWDS (Federal Style) via `@trussworks/react-uswds` + Tailwind CSS.
* **Architecture:** * **Tokens:** Style Dictionary (v4) for centralized styling variables.
    * **Layering:** "Sandwich Strategy" (Base < USWDS < CMM < Utilities) in `index.css`.
* **Key Components:** `IngestionForm` (Data Entry), `CmmTranscriptCard` (Data Display), `TranscriptViewer` (Interactive list).

### **Backend (`/backend`)**
* **Framework:** FastAPI (Python 3.12+).
* **Core Libraries:**
    * `yt-dlp`: **Primary extraction tool.** Used for resolving Playlists/Channels and handling authentication (cookies) for private content access.
    * `youtube-transcript-api`: For extracting raw subtitles/timestamps.
    * `llama-index` / `langchain`: Orchestration.
    * `chromadb` (Local) or `pinecone` (Cloud): Vector Store.
* **RAG Strategy (The "Senior" Stack):**
    * **Retrieval Method:** **Hybrid Search (Vector + BM25)** using **Reciprocal Rank Fusion (RRF)**. This ensures precise keyword matching for specific terms (BM25) while maintaining semantic understanding (Vector).
    * **Indexing Strategy:** **Parent-Child (Small-to-Big) Indexing**. 
        * *Child Nodes:* Small chunks (e.g., 2 sentences) indexed for high-precision search hits.
        * *Parent Nodes:* Larger windows (e.g., 3 minutes) retrieved for LLM context to ensure answer quality.
* **Data Model:**
* **Document:** Full video transcript.
* **Parent Node:** Context window (~1024 tokens) with metadata `video_id`, `start_time`, `end_time`.
* **Child Node:** Search target (~128-256 tokens) linking back to `parent_id`.

## 3. CMM Role Alignment & Learning Objectives
This project specifically targets the **UI Styling Specialist** competencies:

* **Design Ops:** Implementing an automated token pipeline (`json` -> `css`/`js`/`ts`) to simulate maintaining a "unified visual identity" across modules.
* **Accessibility (508/WCAG):** Utilizing USWDS components to ensure screen reader compatibility and high-contrast compliance by default.
* **Responsive Layouts:** Using USWDS Grid and Tailwind flex/grid utilities to build "scalable, production-ready" interfaces.
* **System Architecture:** Decoupling "Design Decisions" (Tokens) from "Implementation Details" (CSS/Components).

## 4. Current State (Frontend)
* **Token Pipeline:** Functional. `sd.config.js` generates CSS variables and a flat JSON file for Tailwind.
* **UI Components:** `CmmButton` (Gold/Primary variants), `CmmUrlInput` (Accessible Forms), `CmmTranscriptCard` (High-density display).
* **Routing:** Client-side routing implemented with `react-router-dom` for multi-page navigation.
* **Pagination:** Accessible, URL-driven pagination system integrated for list displays.
* **Storybook Documentation:** Comprehensive descriptions added to all existing Storybook stories for better context and understanding.
* **Layer Architecture:** `index.css` successfully implements cascade layers (`base`, `uswds`, `cmm`, `utilities`) to manage specificity, ensuring `cmm` overrides USWDS defaults and unlayered Tailwind utilities maintain their priority without relying on `!important` prefixes.
* **Typography Tokenization:** Abstracted font families (`Inter`, `Merriweather`) and weights into `src/tokens/cmm/typography.json`.
* **Custom Transcript Card:** Created a high-density data display component (typical of Case Management systems) using the new typography tokens.
* **Automated "Zero Trust" Accessibility Pipeline:**
    * Installed `storybook-addon-a11y` to visualize WCAG compliance in real-time.
    * Installed `vitest-axe` and implemented a unit test that asserts `expect(container).toHaveNoViolations()` for the `CmmTranscriptCard`.
* **Semantic Token "Aliasing" (DesignOps):** Refactor `src/tokens` to use a 3-tier structure (Base -> Semantic -> Component). Update Style Dictionary to resolve aliases (e.g., `button.primary.bg` -> `color.action.blue` -> `#005ea2`).
* **High-Performance Virtualization:** Implement `@tanstack/react-virtual` for the Transcript Viewer to render large datasets without DOM performance degradation. Aim for TTI < 2s.

## 5. Roadmap & Next Steps

### **Phase 2: Backend Core & Advanced Retrieval (Immediate Priority)**

**1. Repository & Environment Foundation**

* [ ] **Repo Restructure:** Move current React files into `frontend/` and initialize `backend/`.
* [ ] **Python Environment:** Initialize `poetry` with Python 3.12+.
* [ ] **Dependency Management:** Install core deps (`fastapi`, `uvicorn`, `llama-index`, `yt-dlp`, `chromadb`).

**2. FastAPI Application Skeleton**

* [ ] **App Factory:** Create `app/main.py` with an application factory pattern for modularity.
* [ ] **Router Config:** Set up `app/api/v1/` structure for future versioning.
* [ ] **Health Check:** Implement `GET /health` endpoint to verify service status.

**3. Video Acquisition Service (The "Loader" Layer)**

* [ ] **Cookie Management:** Implement a secure loader to read `cookies.txt` (via env path) for `yt-dlp` authentication (Critical for private playlists).
* [ ] **Playlist Resolver:** Create `YtDlpService` to handle `extract_flat` logic, converting Playlist/Channel URLs into a list of video IDs.
* [ ] **Transcript Fetcher:** Create `TranscriptService` to wrap `youtube-transcript-api` and standardize the output format (text + timestamps).

**4. Advanced Indexing Pipeline (Parent-Child Architecture)**

* [ ] **Node Parsing Strategy:** Configure `HierarchicalNodeParser` with specific chunk sizes (e.g., Parent: 512, Child: 128) to create the relational link.
* [ ] **Dual-Storage Setup:**
* **DocStore:** Initialize `SimpleDocumentStore` (or MongoDB later) to hold the large *Parent Nodes*.
* **VectorStore:** Initialize `ChromaVectorStore` to hold the searchable *Child Nodes*.
* [ ] **Batch Ingestion Pipeline:** Create the logic to iterate through a list of Video IDs (from the Playlist Resolver), fetching and indexing each transcript sequentially or in parallel.
* [ ] Build the logic that accepts a transcript, parses it into Parent/Child nodes, and persists them to their respective stores.

**5. Hybrid Retrieval Engine Implementation**

* [ ] **Vector Retriever:** Instantiate `VectorIndexRetriever` connected to the ChromaDB index (Targeting Child Nodes).
* [ ] **Keyword Retriever:** Instantiate `BM25Retriever` connected to the DocStore (Targeting Child Nodes).
* [ ] **Fusion Layer:** Implement `QueryFusionRetriever` wrapping both retrievers with `mode="reciprocal_rerank"`.
* [ ] **Context Resolution:** Implement the `RecursiveRetriever` logic to ensure that when a Child Node is found, the *Parent Node* is what gets returned to the LLM.

### **Phase 3: The "Chat" Loop**
* [ ] **Ingestion Endpoint:** `POST /api/ingest` -> Accepts URL (Video or Playlist), returns Job ID + Status.
* [ ] **Query Endpoint:** `POST /api/chat` -> Accepts user question, performs Hybrid/RRF search, returns Answer + Source Chunks (with timestamps).
* [ ] **Frontend Integration:** Connect `IngestionForm` to the backend. Create the `ChatInterface` component.

### **Phase 4: Advanced Synthesis & Intelligence**
* **Cross-Video Synthesis:** Enable the RAG engine to draw connections and contrast information across multiple videos (e.g., "Summarize the evolution of this topic across the entire playlist").
* **Advanced Filtering:** For example, allow the user to select only certain videos from the playlist.
* **Knowledge Augmentation or comparison:** Allow the user to upload a set of external documents to augment or compare/contrast the information in the transcripts.
* **Channel Intelligence:** Logic to fetch top 'N' videos from a channel URL for broad trend analysis.

#### TBD Phase 5: Hardening and GDIT Skills Study (Low Priority)
* [ ] **DevSecOps Containerization (DevContainers)**
Why: This is specifically designed for local environments. By setting up .devcontainer, you prove you can enforce a standard environment for any developer who clones your repo, mirroring how federal teams standardize onboarding.
Local Action: Install Docker Desktop and the "Dev Containers" extension in VS Code. Create the config to lock your Node version and extensions.

* [ ] **Federal Accessibility Standards (Trusted Tester V5 + VPAT)**
Why: This is a manual auditing process. It requires no infrastructure, just your browser and a spreadsheet (the VPAT).
Local Action: Install the "ANDI" (Accessible Name & Description Inspector) browser bookmarklet (the modern alternative to WAT) and fill out a mock VPAT for your CmmTranscriptCard.

* [ ] **Design System Governance & Versioning**
Why: This operates entirely within Git. You don't need a remote CI server to manage versioning.
Local Action: Install @changesets/cli. Run npx changeset locally after making a CSS change to see how it generates a changelog entry.

* [ ] **SSR Hydration & Performance**
Why: This is pure code. You can test "Flash of Unstyled Content" (FOUC) by throttling your network speed in Chrome DevTools to "Slow 3G" running on localhost.
Local Action: Implement the <head> script updates in your index.html (Vite) and verify the painting performance in Chrome's "Performance" tab.

## Custom Instructions
Keep these instructions in mind when performing tasks: 
- New components should always be created with their accompanying story in Storybook
- Component updates and new patterns should also be addressed in Storybook
- Do not inherently run any `git` command, `npm start dev`, `npm start storybook`, `npm run build`, or `npm i` actions unless explicitly instructed. Instead ask the user to run these commands and report back the results.
- Keep GEMINI.md and README.md updated as necessary.