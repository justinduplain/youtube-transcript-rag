# Project Context: YouTube Transcript RAG Pipeline & CMM Design System Study

## 1. Executive Summary
This project serves a dual purpose:
1.  **Functional:** A Retrieval-Augmented Generation (RAG) pipeline that ingests individual YouTube videos (Phase 2), extracts transcripts, vectorizes them, and allows users to chat with the video content. Eventually (in Phase 4), the goal is to allow the user to select several videos from a YouTube channel (or several channels) and a time window or multi-video select feature to give more context and depth to the references.
    1. Standout Feature: Time-Referenced Video Deep Links. The core innovation of this RAG pipeline is the Time-Referenced Video Deep Link. Unlike standard chatbots that provide opaque summaries, this application bridges the gap between the generated answer and the source truth.Precision Citations: Every claim generated by the LLM is backed by a specific segment of the transcript. The system identifies the exact start time of the relevant context.
       1. Instant Verification: Citations are rendered as interactive timestamps (e.g., [04:23]). Clicking these links opens the source YouTube video at that exact second, allowing users to immediately verify the AI's interpretation against the original audio and visual context.
       2. Contextual Anchoring: This feature transforms the application from a simple summarizer into a Zero Trust research tool, where the user can always "audit" the AI's reasoning by viewing the primary source material.

2.  **Educational (CMM Alignment):** A "Zero Trust" Federal Design System sandbox. The UI architecture mirrors the specific requirements of the **Case Management Modernization (CMM)** program, focusing on **USWDS compliance**, **Design Tokens (Style Dictionary)**, **Tailwind CSS**, and strict **Section 508 Accessibility**.

## 2. Technical Architecture

### **Frontend (`/frontend`)**
* **Stack:** React 18 + Vite + TypeScript.
* **Design System:** USWDS (Federal Style) via `@trussworks/react-uswds` + Tailwind CSS.
* **Architecture:** * **Tokens:** Style Dictionary (v4) for centralized styling variables.
    * **Layering:** "Sandwich Strategy" (Base < USWDS < CMM < Utilities) in `index.css`.
* **Key Components:** `IngestionForm` (Data Entry), `CmmTranscriptCard` (Data Display), `TranscriptViewer` (Interactive list).

### **Backend (`/backend`)**
* **Framework:** FastAPI (Python 3.12+).
* **Core Libraries:**
    * `youtube-transcript-api`: For extracting subtitles/timestamps.
    * `langchain` / `llama-index`: For orchestration.
    * `chromadb` (Local) or `pinecone` (Cloud): Vector Store.
    * `openai` or `ollama`: LLM Inference.
* **Data Model:** * **Document:** Full transcript.
    * **Chunk:** ~500-1000 character segment containing `text`, `start_time`, `end_time`, and `video_id` metadata.

## 3. CMM Role Alignment & Learning Objectives
This project specifically targets the **UI Styling Specialist** competencies:

* **Design Ops:** Implementing an automated token pipeline (`json` -> `css`/`js`/`ts`) to simulate maintaining a "unified visual identity" across modules.
* **Accessibility (508/WCAG):** Utilizing USWDS components to ensure screen reader compatibility and high-contrast compliance by default.
* **Responsive Layouts:** Using USWDS Grid and Tailwind flex/grid utilities to build "scalable, production-ready" interfaces.
* **System Architecture:** Decoupling "Design Decisions" (Tokens) from "Implementation Details" (CSS/Components).

## 4. Current State (Frontend)
* **Token Pipeline:** Functional. `sd.config.js` generates CSS variables and a flat JSON file for Tailwind.
* **UI Components:** `CmmButton` (Gold/Primary variants), `CmmUrlInput` (Accessible Forms), `CmmTranscriptCard` (High-density display).
* **Routing:** Client-side routing implemented with `react-router-dom` for multi-page navigation.
* **Pagination:** Accessible, URL-driven pagination system integrated for list displays.
* **Storybook Documentation:** Comprehensive descriptions added to all existing Storybook stories for better context and understanding.
* **Layer Architecture:** `index.css` successfully implements cascade layers (`base`, `uswds`, `cmm`, `utilities`) to manage specificity, ensuring `cmm` overrides USWDS defaults and unlayered Tailwind utilities maintain their priority without relying on `!important` prefixes.
* **Typography Tokenization:** Abstracted font families (`Inter`, `Merriweather`) and weights into `src/tokens/cmm/typography.json`.
* **Custom Transcript Card:** Created a high-density data display component (typical of Case Management systems) using the new typography tokens.
* **Automated "Zero Trust" Accessibility Pipeline:**
    * Installed `storybook-addon-a11y` to visualize WCAG compliance in real-time.
    * Installed `vitest-axe` and implemented a unit test that asserts `expect(container).toHaveNoViolations()` for the `CmmTranscriptCard`.
* **Semantic Token "Aliasing" (DesignOps):** Refactor `src/tokens` to use a 3-tier structure (Base -> Semantic -> Component). Update Style Dictionary to resolve aliases (e.g., `button.primary.bg` -> `color.action.blue` -> `#005ea2`).
* **High-Performance Virtualization:** Implement `@tanstack/react-virtual` for the Transcript Viewer to render large datasets without DOM performance degradation. Aim for TTI < 2s.

## 5. Roadmap & Next Steps

### **Phase 2: Backend Foundation (Immediate Priority)**
* [ ] **Repo Restructure:** Move current React files into a `frontend/` folder and initialize a `backend/` folder for Python.
* [ ] **FastAPI Setup:** Initialize `poetry` or `venv`. Create `main.py` with a health check endpoint.
* [ ] **Transcript Service:** Implement `YouTubeLoader` to fetch transcripts *with timestamps*.
* [ ] **Smart Chunking:** Implement a chunking strategy that preserves time metadata (critical for the Deep Link feature).
* [ ] **Vector Store:** Setup ChromaDB (local) to store embeddings.

### **Phase 3: The "Chat" Loop**
* [ ] **Ingestion Endpoint:** `POST /api/ingest` -> Accepts URL, returns Job ID + Status.
* [ ] **Query Endpoint:** `POST /api/chat` -> Accepts user question, performs similarity search, returns Answer + Source Chunks (with timestamps).
* [ ] **Frontend Integration:** Connect `IngestionForm` to the backend. Create the `ChatInterface` component.

### **Phase 4: Multi-Video Intelligence**
* **Multi-Video/Playlist Selection:** Allows logged-in YouTube user to select a playlist; the RAG provides context based on the full set.
#### TBD Phase 5: Hardenting and GDIT Skills Study (Low Priority)
* [ ] **DevSecOps Containerization (DevContainers)II
Why: This is specifically designed for local environments. By setting up .devcontainer, you prove you can enforce a standard environment for any developer who clones your repo, mirroring how federal teams standardize onboarding.
Local Action: Install Docker Desktop and the "Dev Containers" extension in VS Code. Create the config to lock your Node version and extensions.

* [ ] **Federal Accessibility Standards (Trusted Tester V5 + VPAT)**
Why: This is a manual auditing process. It requires no infrastructure, just your browser and a spreadsheet (the VPAT).
Local Action: Install the "ANDI" (Accessible Name & Description Inspector) browser bookmarklet (the modern alternative to WAT) and fill out a mock VPAT for your CmmTranscriptCard.

* [ ] **Design System Governance & Versioning**
Why: This operates entirely within Git. You don't need a remote CI server to manage versioning.
Local Action: Install @changesets/cli. Run npx changeset locally after making a CSS change to see how it generates a changelog entry.

* [ ] **SSR Hydration & Performance**
Why: This is pure code. You can test "Flash of Unstyled Content" (FOUC) by throttling your network speed in Chrome DevTools to "Slow 3G" running on localhost.
Local Action: Implement the <head> script updates in your index.html (Vite) and verify the painting performance in Chrome's "Performance" tab.

## Custom Instructions
Keep these instrucitons in mind when performing tasks: 
- New components should always be created with their accompanying story in Storybook
- Component updates and new patters should also be addressed in Storybook
- Do not inherintely run any `git` command, `npm start dev`, `npm start storybook`, `npm run build`, or `npm i` actions unless explicitly instructed. Instead ask the user to run these commands and report back the results.
- Keep GEMINI.md and README.md updated as necessary.